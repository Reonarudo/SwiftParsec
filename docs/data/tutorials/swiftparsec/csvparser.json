{"variants":[{"paths":["\/tutorials\/swiftparsec\/csvparser"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this tutorial, we’ll walk through the process of building a CSV parser using SwiftParsec. The CSV (comma-separated values) format is commonly used for storing tabular data. We’ll leverage the power of SwiftParsec’s primitive and combinator parsers to create a robust and flexible CSV parser in just a few lines of code."}]}],"estimatedTimeInMinutes":10,"title":"Building a CSV Parser with SwiftParsec","image":"csv.png","chapter":"Building a CSV Parser with SwiftParsec","kind":"hero","backgroundImage":"csv.png"},{"kind":"tasks","tasks":[{"anchor":"Introduction-to-SwiftParsec","title":"Introduction to SwiftParsec","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftParsec provides various features for parsing, including primitive parsers, combinator parsers, operators, and basic string parsers. It uses a type alias called GenericParser with three type parameters: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Stream"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Parsec\/UserState-swift.associatedtype"},{"type":"text","text":", and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Parsec\/Result"},{"type":"text","text":". The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Stream"},{"type":"text","text":" type represents the type of the input stream to parse, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Parsec\/UserState-swift.associatedtype"},{"type":"text","text":" is the user-supplied state passed around combined parsers (can be set to Void if not used), and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Parsec\/Result"},{"type":"text","text":" is the type of the result the parser returns upon success."}]}],"mediaPosition":"trailing"}],"stepsSection":[{"code":"csv-setup.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s start by importing SwiftParsec and setting up the initial structure of our CSV parser."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We define a function "},{"type":"codeVoice","code":"csvParser()"},{"type":"text","text":" that returns a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser"},{"type":"text","text":" with the specified type parameters. Our CSV parser will parse a string input, not use any user state, and return a two-dimensional array of strings "},{"type":"codeVoice","code":"[[String]]"},{"type":"text","text":", representing the parsed CSV data."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"csv-quoted.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this step, we define parsers for handling quoted characters."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"quotedChars"},{"type":"text","text":" parser combines two alternatives using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/___(_:_:)-t050"},{"type":"text","text":" operator. The first alternative, "},{"type":"codeVoice","code":"noneOf(\"\\\"\")"},{"type":"text","text":", matches any character not equal to a double quote using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/noneOf(_:)"},{"type":"text","text":". The second alternative, "},{"type":"codeVoice","code":"StringParser.string(\"\\\"\\\"\").attempt *> GenericParser(result: \"\\\"\")"},{"type":"text","text":", handles the case of two consecutive double quotes. By using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/attempt"},{"type":"text","text":" combinator with the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/*_(_:_:)"},{"type":"text","text":" operator, we discard the result of matching two consecutive double quotes and keep the result of a single double quote. This ensures that we return a single double quote as the result when parsing quoted characters."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"csv-fields.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this step, we define parsers for parsing fields, both quoted and non-quoted."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We create a "},{"type":"codeVoice","code":"character"},{"type":"text","text":" constant using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Parsec\/character(_:)"},{"type":"text","text":" to match a single character. The "},{"type":"codeVoice","code":"quotedField"},{"type":"text","text":" parser handles fields enclosed in double quotes by parsing the opening quote, applying the "},{"type":"codeVoice","code":"quotedChars"},{"type":"text","text":" parser multiple times using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/many"},{"type":"text","text":" combinator, and parsing the closing quote. The "},{"type":"codeVoice","code":"field"},{"type":"text","text":" parser uses the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/___(_:_:)-t050"},{"type":"text","text":" operator to try parsing a "},{"type":"codeVoice","code":"quotedField"},{"type":"text","text":" first and, if it fails, tries parsing a non-quoted field using the "},{"type":"codeVoice","code":"noneOf"},{"type":"text","text":" parser."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"csv-records.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this step, we define a parser for parsing records, which consist of multiple fields separated by commas."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"record"},{"type":"text","text":" parser uses the "},{"type":"codeVoice","code":"field"},{"type":"text","text":" parser followed by the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/separatedBy(_:)"},{"type":"text","text":" combinator with the "},{"type":"codeVoice","code":"character(\",\")"},{"type":"text","text":" parser."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"csv-crlf.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this step, we handle parsing the end of a line in the CSV."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We define the "},{"type":"codeVoice","code":"endOfLine"},{"type":"text","text":" parser using various options, including matching combinations of carriage return and newline characters, as well as individual newline and carriage return characters."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"csv-parser.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this step, we combine the "},{"type":"codeVoice","code":"record"},{"type":"text","text":" parser with the "},{"type":"codeVoice","code":"endOfLine"},{"type":"text","text":" parser to create our CSV parser."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"csv"},{"type":"text","text":" parser allows parsing zero or more records separated by the "},{"type":"codeVoice","code":"endOfLine"},{"type":"text","text":" parser."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"csv-testing.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this final step, you can pass a sample CSV string to the "},{"type":"codeVoice","code":"csvParser().test()"},{"type":"text","text":" function to test the parser and see the parsed output."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"csvData"},{"type":"text","text":" variable contains a sample CSV string with multiple records and fields. We pass this string to the "},{"type":"codeVoice","code":"csvParser().test()"},{"type":"text","text":" function, which applies our CSV parser to the input and returns the parsed result into the "},{"type":"codeVoice","code":"result"},{"type":"text","text":" variable, which is a two-dimensional array of strings. We then print the "},{"type":"codeVoice","code":"result"},{"type":"text","text":" to see the parsed CSV data."}]}],"type":"step","runtimePreview":null,"media":null},{"code":"csv-testing-result.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When you run this code, the output will be the parsed CSV data represented as a two-dimensional array of strings, where each inner array corresponds to a record and contains the individual field values."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null}]}]},{"action":{"overridingTitleInlineContent":[{"type":"text","text":"Get started"}],"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/JSONParser","overridingTitle":"Get started"},"featuredEyebrow":"Tutorial","kind":"callToAction","title":"Building a JSON Parser with SwiftParsec","abstract":[{"type":"text","text":"In this tutorial, we will explore the process of building a JSON parser using a tokenizer. While Swift already provides native support for JSON parsing using Codable, understanding the underlying principles and techniques can be valuable. We will leverage the power of SwiftParsec, which offers a GenericTokenParser type that simplifies the creation of tokenizers. By following this tutorial, you will gain insights into how JSON parsing works and enhance your understanding of parsing techniques in Swift. It’s worth noting that for most use cases, you can rely on Swift’s Codable protocol for JSON parsing. However, building a JSON parser from scratch allows us to dive deeper into the inner workings and principles of parsing in Swift. So let’s get started and build our own JSON parser!"}]}],"identifier":{"url":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/CSVParser","interfaceLanguage":"swift"},"kind":"project","metadata":{"title":"Building a CSV Parser with SwiftParsec","categoryPathComponent":"Table-of-Contents","role":"project","category":"SwiftParsec Tutorials"},"hierarchy":{"modules":[{"reference":"doc:\/\/SwiftParsec\/tutorials\/Table-of-Contents\/Building-a-CSV-Parser-with-SwiftParsec","projects":[{"reference":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/CSVParser","sections":[{"kind":"task","reference":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/CSVParser#Introduction-to-SwiftParsec"}]}]},{"reference":"doc:\/\/SwiftParsec\/tutorials\/Table-of-Contents\/Building-a-JSON-Parser-with-SwiftParsec","projects":[{"reference":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/JSONParser","sections":[{"kind":"task","reference":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/JSONParser#Digging-Deeper"}]}]}],"reference":"doc:\/\/SwiftParsec\/tutorials\/Table-of-Contents","paths":[["doc:\/\/SwiftParsec\/tutorials\/Table-of-Contents","doc:\/\/SwiftParsec\/tutorials\/Table-of-Contents\/$volume","doc:\/\/SwiftParsec\/tutorials\/Table-of-Contents\/Building-a-CSV-Parser-with-SwiftParsec"]]},"references":{"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/separatedBy(_:)":{"conformance":{"constraints":[{"type":"codeVoice","code":"StreamType"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Stream"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"separatedBy(_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"separatedBy"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Separator"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Separator"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", ["},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":"]>"}],"abstract":[{"type":"text","text":"Return a parser that parses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"zero"}]},{"type":"text","text":" or more occurrences of "},{"type":"codeVoice","code":"self"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"separated by "},{"type":"codeVoice","code":"separator"},{"type":"text","text":". It returns an array of values returned by"},{"type":"text","text":" "},{"type":"codeVoice","code":"self"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/separatedBy(_:)","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/separatedby(_:)"},"doc://SwiftParsec/tutorials/SwiftParsec/CSVParser":{"role":"project","title":"Building a CSV Parser with SwiftParsec","estimatedTime":"10min","abstract":[{"type":"text","text":"In this tutorial, we’ll walk through the process of building a CSV parser using SwiftParsec. The CSV (comma-separated values) format is commonly used for storing tabular data. We’ll leverage the power of SwiftParsec’s primitive and combinator parsers to create a robust and flexible CSV parser in just a few lines of code."}],"identifier":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/CSVParser","kind":"project","type":"topic","url":"\/tutorials\/swiftparsec\/csvparser"},"doc://SwiftParsec/tutorials/SwiftParsec/JSONParser":{"role":"project","title":"Building a JSON Parser with SwiftParsec","estimatedTime":"20min","abstract":[{"type":"text","text":"In this tutorial, we will explore the process of building a JSON parser using a tokenizer. While Swift already provides native support for JSON parsing using Codable, understanding the underlying principles and techniques can be valuable. We will leverage the power of SwiftParsec, which offers a GenericTokenParser type that simplifies the creation of tokenizers. By following this tutorial, you will gain insights into how JSON parsing works and enhance your understanding of parsing techniques in Swift. It’s worth noting that for most use cases, you can rely on Swift’s Codable protocol for JSON parsing. However, building a JSON parser from scratch allows us to dive deeper into the inner workings and principles of parsing in Swift. So let’s get started and build our own JSON parser!"}],"identifier":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/JSONParser","kind":"project","type":"topic","url":"\/tutorials\/swiftparsec\/jsonparser"},"csv-fields.swift":{"syntax":"swift","content":["import SwiftParsec","","func csvParser() -> GenericParser<String, (), [[String]]> {","    \/\/ Parser code goes here","    let noneOf = StringParser.noneOf","","    let quotedChars = noneOf(\"\\\"\") <|>","    StringParser.string(\"\\\"\\\"\").attempt *>","    GenericParser(result: \"\\\"\")","","    let character = StringParser.character","","    let quote = character(\"\\\"\")","    let quotedField = quote *> quotedChars.many.stringValue <*","    (quote <?> \"quote at end of field\")","","    let field = quotedField <|> noneOf(\"\\r\\n,\\n\\r\").many.stringValue","","    \/\/...","}"],"fileName":"CSVParser.swift","identifier":"csv-fields.swift","type":"file","fileType":"swift","highlights":[{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18}]},"csv-testing-result.swift":{"syntax":"","content":["[","    [\"Last Name\", \"First Name\", \"Phone\"],","    [\"Appleseed\", \"Johnny\", \"123-456-7890\"],","    [\"Doe\", \"John\", \"234-567-8901\"],","    [\"Doe\", \"Jane\", \"345-678-9012\"],","    [\"Roe\", \"John \\\"Richard\\\"\", \"000-000-0000\"],","    [\"Roe\", \"Jane, J.\", \"111-111-1111\"]","]"],"fileName":"Output","identifier":"csv-testing-result.swift","type":"file","fileType":"","highlights":[]},"doc://SwiftParsec/documentation/SwiftParsec/*_(_:_:)":{"role":"symbol","title":"*>(_:_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"*>"},{"kind":"text","text":" "},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"StreamType"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"UserState"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"Param1"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"Param2"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Param1"},{"kind":"text","text":">, "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Param2"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Param2"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Sequence parsing, discarding the value of the first parser. It has the same"},{"type":"text","text":" "},{"type":"text","text":"precedence as the equality operator ("},{"type":"codeVoice","code":"=="},{"type":"text","text":")."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/*_(_:_:)","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/*_(_:_:)"},"doc://SwiftParsec/tutorials/SwiftParsec/CSVParser#Introduction-to-SwiftParsec":{"role":"pseudoSymbol","title":"Introduction to SwiftParsec","abstract":[{"type":"text","text":"In this tutorial, we’ll walk through the process of building a CSV parser using SwiftParsec. The CSV (comma-separated values) format is commonly used for storing tabular data. We’ll leverage the power of SwiftParsec’s primitive and combinator parsers to create a robust and flexible CSV parser in just a few lines of code."}],"identifier":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/CSVParser#Introduction-to-SwiftParsec","kind":"section","type":"section","url":"\/tutorials\/swiftparsec\/csvparser#Introduction-to-SwiftParsec"},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/many":{"role":"symbol","title":"many","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"many"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", ["},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":"]>"}],"abstract":[{"type":"text","text":"The "},{"type":"codeVoice","code":"many"},{"type":"text","text":" combinator applies the parser "},{"type":"codeVoice","code":"self"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"zero"}]},{"type":"text","text":" or more times. It"},{"type":"text","text":" "},{"type":"text","text":"returns an array of the returned values of "},{"type":"codeVoice","code":"self"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/many","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/many"},"doc://SwiftParsec/tutorials/Table-of-Contents":{"role":"overview","title":"Introduction to SwiftParsec","abstract":[{"type":"text","text":"Get ready to dive into the world of SwiftParsec! In this section, we’ll introduce you to SwiftParsec and its powerful parsing capabilities. Whether you’re new to parsing or have some experience, SwiftParsec provides a user-friendly and expressive approach to building parsers. Prepare to unlock the potential of parsing with SwiftParsec!"}],"identifier":"doc:\/\/SwiftParsec\/tutorials\/Table-of-Contents","kind":"overview","type":"topic","url":"\/tutorials\/table-of-contents"},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/attempt":{"role":"symbol","title":"attempt","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"attempt"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"This combinator is used whenever arbitrary look ahead is needed. Since"},{"type":"text","text":" "},{"type":"text","text":"it pretends that it hasn’t consumed any input when "},{"type":"codeVoice","code":"self"},{"type":"text","text":" fails, the"},{"type":"text","text":" "},{"type":"text","text":"(’<|>’) combinator will try its second alternative even when the first"},{"type":"text","text":" "},{"type":"text","text":"parser failed while consuming input."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/attempt","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/attempt"},"doc://SwiftParsec/tutorials/SwiftParsec/JSONParser#Digging-Deeper":{"role":"pseudoSymbol","title":"Digging Deeper","abstract":[{"type":"text","text":"In this tutorial, we will explore the process of building a JSON parser using a tokenizer. While Swift already provides native support for JSON parsing using Codable, understanding the underlying principles and techniques can be valuable. We will leverage the power of SwiftParsec, which offers a GenericTokenParser type that simplifies the creation of tokenizers. By following this tutorial, you will gain insights into how JSON parsing works and enhance your understanding of parsing techniques in Swift. It’s worth noting that for most use cases, you can rely on Swift’s Codable protocol for JSON parsing. However, building a JSON parser from scratch allows us to dive deeper into the inner workings and principles of parsing in Swift. So let’s get started and build our own JSON parser!"}],"identifier":"doc:\/\/SwiftParsec\/tutorials\/SwiftParsec\/JSONParser#Digging-Deeper","kind":"section","type":"section","url":"\/tutorials\/swiftparsec\/jsonparser#Digging-Deeper"},"doc://SwiftParsec/documentation/SwiftParsec/Parsec/Result":{"role":"symbol","title":"Result","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"Result"}],"abstract":[{"type":"text","text":"The result of the parser."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Parsec\/Result","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/swiftparsec\/parsec\/result"},"csv-parser.swift":{"syntax":"swift","content":["import SwiftParsec","","func csvParser() -> GenericParser<String, (), [[String]]> {","    \/\/ Parser code goes here","    let noneOf = StringParser.noneOf","","    let quotedChars = noneOf(\"\\\"\") <|>","    StringParser.string(\"\\\"\\\"\").attempt *>","    GenericParser(result: \"\\\"\")","","    let character = StringParser.character","","    let quote = character(\"\\\"\")","    let quotedField = quote *> quotedChars.many.stringValue <*","    (quote <?> \"quote at end of field\")","","    let field = quotedField <|> noneOf(\"\\r\\n,\\n\\r\").many.stringValue","","    let record = field.separatedBy(character(\",\"))","","    let endOfLine = StringParser.crlf.attempt <|>","    (character(\"\\n\") *> character(\"\\r\")).attempt <|>","    character(\"\\n\") <|>","    character(\"\\r\") <?> \"end of line\"","","    let csv = record.separatedBy(endOfLine)","","    return csv","}"],"fileName":"CSVParser.swift","identifier":"csv-parser.swift","type":"file","fileType":"swift","highlights":[{"line":26},{"line":27},{"line":28}]},"csv.png":{"alt":"Building a CSV Parser with SwiftParsec","type":"image","identifier":"csv.png","variants":[{"url":"\/images\/csv@2x.png","traits":["2x","light"]}]},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/___(_:_:)-t050":{"role":"symbol","title":"<|>(_:_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"<|>"},{"kind":"text","text":" "},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Self"}],"abstract":[{"type":"text","text":"Infix operator for "},{"type":"codeVoice","code":"Parsec.alternative"},{"type":"text","text":". It has a higher precedence than"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":">>-"},{"type":"text","text":" operator."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/___(_:_:)-t050","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/___(_:_:)-t050"},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/noneOf(_:)":{"conformance":{"constraints":[{"type":"codeVoice","code":"Result"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" and "},{"type":"codeVoice","code":"StreamType.ArrayLiteralElement"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Character"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"noneOf(_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"noneOf"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Return a parser that succeeds if the current character is "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" in the"},{"type":"text","text":" "},{"type":"text","text":"supplied list of characters. It returns the parsed character."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/noneOf(_:)","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/noneof(_:)"},"csv-setup.swift":{"syntax":"swift","content":["import SwiftParsec","","func csvParser() -> GenericParser<String, (), [[String]]> {","    \/\/ Parser code goes here","}"],"fileName":"CSVParser.swift","identifier":"csv-setup.swift","type":"file","fileType":"swift","highlights":[]},"doc://SwiftParsec/tutorials/Table-of-Contents/Building-a-CSV-Parser-with-SwiftParsec":{"role":"article","title":"Building a CSV Parser with SwiftParsec","abstract":[],"identifier":"doc:\/\/SwiftParsec\/tutorials\/Table-of-Contents\/Building-a-CSV-Parser-with-SwiftParsec","kind":"article","type":"topic","url":"\/tutorials\/table-of-contents\/building-a-csv-parser-with-swiftparsec"},"csv-crlf.swift":{"syntax":"swift","content":["import SwiftParsec","","func csvParser() -> GenericParser<String, (), [[String]]> {","    \/\/ Parser code goes here","    let noneOf = StringParser.noneOf","","    let quotedChars = noneOf(\"\\\"\") <|>","    StringParser.string(\"\\\"\\\"\").attempt *>","    GenericParser(result: \"\\\"\")","","    let character = StringParser.character","","    let quote = character(\"\\\"\")","    let quotedField = quote *> quotedChars.many.stringValue <*","    (quote <?> \"quote at end of field\")","","    let field = quotedField <|> noneOf(\"\\r\\n,\\n\\r\").many.stringValue","","    let record = field.separatedBy(character(\",\"))","","    let endOfLine = StringParser.crlf.attempt <|>","    (character(\"\\n\") *> character(\"\\r\")).attempt <|>","    character(\"\\n\") <|>","    character(\"\\r\") <?> \"end of line\"","","    \/\/...","}"],"fileName":"CSVParser.swift","identifier":"csv-crlf.swift","type":"file","fileType":"swift","highlights":[{"line":21},{"line":22},{"line":23},{"line":24},{"line":25}]},"csv-quoted.swift":{"syntax":"swift","content":["import SwiftParsec","","func csvParser() -> GenericParser<String, (), [[String]]> {","    \/\/ Parser code goes here","    let noneOf = StringParser.noneOf","","    let quotedChars = noneOf(\"\\\"\") <|>","    StringParser.string(\"\\\"\\\"\").attempt *>","    GenericParser(result: \"\\\"\")","","    \/\/...","}"],"fileName":"CSVParser.swift","identifier":"csv-quoted.swift","type":"file","fileType":"swift","highlights":[{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11}]},"csv-testing.swift":{"syntax":"swift","content":["import SwiftParsec","","\/\/ func csvParser() -> GenericParser<String, (), [[String]]> {...}","","let csvData = \"\"\"","Last Name,First Name,Phone","Appleseed,Johnny,123-456-7890","Doe,John,234-567-8901","Doe,Jane,345-678-9012","Roe,\"John \"\"Richard\\\"\"\",000-000-0000","Roe,\"Jane, J.\",111-111-1111","\"\"\"","","csvParser().test(input: csvData)"],"fileName":"CSVParser.swift","identifier":"csv-testing.swift","type":"file","fileType":"swift","highlights":[{"line":3},{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":14}]},"doc://SwiftParsec/tutorials/Table-of-Contents/Building-a-JSON-Parser-with-SwiftParsec":{"role":"article","title":"Building a JSON Parser with SwiftParsec","abstract":[],"identifier":"doc:\/\/SwiftParsec\/tutorials\/Table-of-Contents\/Building-a-JSON-Parser-with-SwiftParsec","kind":"article","type":"topic","url":"\/tutorials\/table-of-contents\/building-a-json-parser-with-swiftparsec"},"doc://SwiftParsec/documentation/SwiftParsec/Parsec/UserState-swift.associatedtype":{"role":"symbol","title":"UserState","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"UserState"}],"abstract":[{"type":"text","text":"The state supplied by the user."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Parsec\/UserState-swift.associatedtype","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/swiftparsec\/parsec\/userstate-swift.associatedtype"},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser":{"role":"symbol","title":"GenericParser","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"GenericParser"}],"abstract":[{"type":"codeVoice","code":"GenericParser"},{"type":"text","text":" is a generic implementation of the "},{"type":"codeVoice","code":"Parsec"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"GenericParser"}],"url":"\/documentation\/swiftparsec\/genericparser"},"doc://SwiftParsec/documentation/SwiftParsec/Parsec/character(_:)":{"conformance":{"constraints":[{"type":"codeVoice","code":"Result"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" and "},{"type":"codeVoice","code":"StreamType.ArrayLiteralElement"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Character"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"character(_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"character"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Character","preciseIdentifier":"s:SJ"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Return a parser that parses a single character "},{"type":"codeVoice","code":"Character"},{"type":"text","text":". It returns"},{"type":"text","text":" "},{"type":"text","text":"the parsed character (i.e. "},{"type":"codeVoice","code":"char"},{"type":"text","text":")."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Parsec\/character(_:)","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/parsec\/character(_:)"},"doc://SwiftParsec/documentation/SwiftParsec/Stream":{"role":"symbol","title":"Stream","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Stream"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Stream"},{"type":"text","text":" instance is responsible for maintaining the position of the"},{"type":"text","text":" "},{"type":"text","text":"parser’s stream."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Stream","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Stream"}],"url":"\/documentation\/swiftparsec\/stream"},"csv-records.swift":{"syntax":"swift","content":["import SwiftParsec","","func csvParser() -> GenericParser<String, (), [[String]]> {","    \/\/ Parser code goes here","    let noneOf = StringParser.noneOf","","    let quotedChars = noneOf(\"\\\"\") <|>","    StringParser.string(\"\\\"\\\"\").attempt *>","    GenericParser(result: \"\\\"\")","","    let character = StringParser.character","","    let quote = character(\"\\\"\")","    let quotedField = quote *> quotedChars.many.stringValue <*","    (quote <?> \"quote at end of field\")","","    let field = quotedField <|> noneOf(\"\\r\\n,\\n\\r\").many.stringValue","","    let record = field.separatedBy(character(\",\"))","","    \/\/...","}"],"fileName":"CSVParser.swift","identifier":"csv-records.swift","type":"file","fileType":"swift","highlights":[{"line":19},{"line":20}]}}}