{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Introduction","level":2,"type":"heading","text":"Introduction"},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftParsec is a pure Swift implementation of the Parsec library. Parsec is a powerful parsing library that uses combinatory parsing to achieve excellent performance and flexibility. With SwiftParsec, you can build complex parsers by combining simple ones."}]},{"anchor":"Installation","level":2,"type":"heading","text":"Installation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Before we start, make sure you have SwiftParsec installed in your project. If you’re using Swift Package Manager, you can add SwiftParsec to your "},{"type":"codeVoice","code":"Package.swift"},{"type":"text","text":" file:"}]},{"type":"codeListing","syntax":"swift","code":["dependencies: [","    .package(url: \"https:\/\/github.com\/davedufresne\/SwiftParsec.git\", from: \"1.0.0\")","]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, add SwiftParsec to your target’s dependencies:"}]},{"type":"codeListing","syntax":"swift","code":[".target(name: \"YourTarget\", dependencies: [\"SwiftParsec\"]),"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, import SwiftParsec in your Swift project:"}]},{"type":"codeListing","syntax":"swift","code":["import SwiftParsec"]},{"anchor":"Creating-a-Simple-Parser","level":2,"type":"heading","text":"Creating a Simple Parser"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In SwiftParsec, you create complex parsers by combining simpler ones. Let’s start with a basic example: a parser that recognizes a single character."}]},{"type":"codeListing","syntax":"swift","code":["let aParser = StringParser.character(\"a\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This parser will match the character “a” in any input string."}]},{"anchor":"Running-a-Parser","level":2,"type":"heading","text":"Running a Parser"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To run a parser, you use the "},{"type":"codeVoice","code":"run"},{"type":"text","text":" function, passing in the input string. Here’s how you can run our "},{"type":"codeVoice","code":"aParser"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let result = try? aParser.run(sourceName: \"Basic usage\", input: \"abc\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the parser successfully matches the input, "},{"type":"codeVoice","code":"run"},{"type":"text","text":" returns the matched value. In this case, "},{"type":"codeVoice","code":"result"},{"type":"text","text":" would be “a”."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case even if we change the input to be “aaaabc” the "},{"type":"codeVoice","code":"result"},{"type":"text","text":" would still be “a”."}]},{"type":"codeListing","syntax":"swift","code":["let result = try? aParser.run(sourceName: \"Basic usage\", input: \"aaaabc\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Even though there are multiple “a” characters at the start of the input string. This is because the parser only matches the first “a” character it encounters, and then it stops parsing."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This limitation can be overcome by using the "},{"type":"codeVoice","code":"many"},{"type":"text","text":" or "},{"type":"codeVoice","code":"many1"},{"type":"text","text":" combinator, which allows the parser to match multiple occurrences of a character. The many combinator matches zero or more occurrences of the parser, while "},{"type":"codeVoice","code":"many1"},{"type":"text","text":" matches one or more occurrences."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how you can create a parser that matches multiple “a” characters:"}]},{"type":"codeListing","syntax":"swift","code":["let aParser = StringParser.character(\"a\").many1.stringValue"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This parser will match one or more “a” characters in any input string and convert them into a string."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now running:"}]},{"type":"codeListing","syntax":"swift","code":["let result = try? aParser.run(sourceName: \"Basic usage\", input: \"aaaabc\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the result of parsing the previous input is “aaaa”."}]},{"anchor":"Combining-Parsers","level":2,"type":"heading","text":"Combining Parsers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The real power of SwiftParsec comes from combining parsers. This is done using combinators, which are functions that take one or more parsers and return a new parser. For example, you can create a parser that recognizes the string “aaaabc” like this:"}]},{"type":"codeListing","syntax":"swift","code":["let abcParser = StringParser.string(\"aaaabc\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or, you can combine our "},{"type":"codeVoice","code":"aParser"},{"type":"text","text":" with another parser that recognizes “bc” using the >>- operator and the lift2 function:"}]},{"type":"codeListing","syntax":"swift","code":["let aParser = StringParser.character(\"a\").many1.stringValue","let bcParser = StringParser.string(\"bc\")","","\/\/ Using the `>>-` operator","let abcParser1 = aParser >>- { a in","    bcParser >>- { bc in","        GenericParser(result: a + bc)","    }","}","","\/\/ Using the `lift2` function","let abcParser2 = GenericParser.lift2(+, parser1: aParser, parser2: bcParser)",""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In these examples, abcParser1 and abcParser2 will first match one or more “a” characters, and then they will match the string “bc”. The results of both parsers are combined into a single string. These are great ways to combine the results of multiple parsers into a single result. By using functions like >>- and lift2, you can create complex parsers that can parse a wide variety of input."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, let’s look at an example of a parser that parses a list of comma-separated numbers:"}]},{"type":"codeListing","syntax":"swift","code":["import SwiftParsec","","let number = StringParser.digit.many1.stringValue.map { Int($0)! }","let comma = StringParser.character(\",\")","let numbers = number.separatedBy(comma)","","if let result = try? numbers.run(sourceName: \"number parser\", input: \"1,2,3,4,5\") {","    print(result)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"n this example, we first define a number parser that matches one or more digits and converts them into an integer. We then define a comma parser that matches the comma character. Finally, we define a numbers parser that matches a list of numbers separated by commas."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The separatedBy combinator is used to match a list of items separated by a separator. In this case, it matches a list of numbers separated by commas."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example demonstrates how you can combine simple parsers to create more complex parsers. By using combinators, you can create parsers that can parse a wide variety of input."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Handling Errors"},{"type":"text","text":" "},{"type":"text","text":"SwiftParsec provides a way to handle errors that may occur during parsing. When a parser fails to match the input, it throws a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/ParseError"},{"type":"text","text":" that you can catch and handle."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of how to handle errors in SwiftParsec:"}]},{"type":"codeListing","syntax":"swift","code":["let aParser = StringParser.character(\"a\")","","do {","    let result = try aParser.run(sourceName: \"error handling\", input: \"b\")","    print(result)","} catch let error as ParseError {","    print(\"Parsing failed with error: \\(error)\")","} catch {","    print(\"An unknown error occurred: \\(error)\")","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, aParser expects to match the character “a”. However, the input string is “b”, so the parser fails to match the input and throws a ParseError."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The do-catch statement is used to handle the error. If a ParseError is thrown, it’s caught and handled by printing an error message. If an unknown error is thrown, it’s also caught and handled by printing a different error message."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The ParseError object contains information about the error, such as the location of the error in the input and a message describing the error. You can use this information to diagnose and fix the error."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you run this code, you’ll see the following output:"}]},{"type":"codeListing","syntax":null,"code":["Parsing failed with error: \"error handling\" (line 1, column 1):","unexpected \"b\"","expecting \"a\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This output tells you that the parser failed at line 1, column 1 of the input, where it encountered an unexpected “b” and was expecting an “a”."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Remember, error handling is an important part of writing a parser. Always make sure to handle errors appropriately in your parsers."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/swiftparsec\/getting-started-with-swiftparsec"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Getting-Started-with-SwiftParsec","interfaceLanguage":"swift"},"kind":"article","metadata":{"roleHeading":"Article","title":"Getting Started with SwiftParsec","role":"article","modules":[{"name":"SwiftParsec"}]},"hierarchy":{"paths":[["doc:\/\/SwiftParsec\/documentation\/SwiftParsec"]]},"references":{"doc://SwiftParsec/documentation/SwiftParsec":{"role":"collection","title":"SwiftParsec","abstract":[{"type":"text","text":"Unleash the Power of Parser Combinators in Swift!"}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec"},"doc://SwiftParsec/documentation/SwiftParsec/ParseError":{"role":"symbol","title":"ParseError","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ParseError"}],"abstract":[{"type":"codeVoice","code":"ParseError"},{"type":"text","text":" represents parse errors. It provides the source position"},{"type":"text","text":" "},{"type":"text","text":"("},{"type":"codeVoice","code":"SourcePosition"},{"type":"text","text":") of the error and an array of error messages ("},{"type":"codeVoice","code":"Message"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"A "},{"type":"codeVoice","code":"ParseError"},{"type":"text","text":" can be returned by the function "},{"type":"codeVoice","code":"parse"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/ParseError","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ParseError"}],"url":"\/documentation\/swiftparsec\/parseerror"}}}