{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Backtracking","level":2,"type":"heading","text":"Backtracking"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Backtracking is a fundamental concept in parsing. It refers to the ability of the parser to “go back” and try a different parsing strategy when it encounters a parsing error. This is crucial in situations where the parser needs to choose between multiple valid parsing paths."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In SwiftParsec, backtracking is handled by the attempt function. This function allows a parser to be tried without consuming any input. If the parser fails, it will not consume any input, allowing the next parser to start from the same position."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s illustrate this with an example. Suppose we have a language that has two types of statements: if statements and print statements. An if statement starts with the keyword if, followed by a condition, and then a block of code. A print statement starts with the keyword print, followed by a string to print."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In SwiftParsec, we can define parsers for these statements like this:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ consumes \"if true { code }\"","let ifStatement = string(\"if\") *> conditionParser *> blockParser","let printStatement = string(\"print\") *> stringLiteralParser"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, suppose we want to parse a statement that could be either an if statement or a print statement. We could try to parse it with the ifStatement parser, and if that fails, we backtrack and try the printStatement parser. This can be done using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/___(_:_:)-t050"},{"type":"text","text":" operator or the quivalent "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/alternative(_:)"},{"type":"text","text":", which tries the parser on the left, and if it fails without consuming input, it tries the parser on the right:"}]},{"type":"codeListing","syntax":"swift","code":["let statement = attempt(ifStatement) <|> printStatement"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, if the input starts with if, the ifStatement parser will be tried. If the input doesn’t match the structure of an if statement (for example, if there’s no condition after the if), the parser will fail and no input will be consumed. Then, the printStatement parser will be tried from the same position."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is how backtracking works in SwiftParsec. It allows the parser to recover from errors and try different parsing strategies, making it possible to parse complex languages with ambiguous syntax."}]},{"anchor":"Lookahead","level":2,"type":"heading","text":"Lookahead"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In some cases, you might want to check if a certain pattern exists in the input, but you don’t want to consume it. This is where "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/lookAhead"},{"type":"text","text":" comes in handy. Lookahead is a technique that allows the parser to peek at the input ahead of the current position without consuming it. This can be useful in situations where the decision to match a certain pattern depends on the surrounding context."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftParsec provides the lookAhead combinator for this purpose. Here’s an example:"}]},{"type":"codeListing","syntax":"swift","code":["import SwiftParsec","","\/\/ Define the grammar of the language","let letterOrDigit = StringParser.letter <|> StringParser.digit","","let identifier = StringParser.letter >>- { first in","    letterOrDigit.many >>- { rest in","        return GenericParser(result: String([first] + rest))","    }","}","","let assignment = identifier >>- { id1 in","    StringParser.character(\"=\") >>- { _ in","        identifier >>- { id2 in","            return GenericParser(result: (id1, id2))","        }","    }","}","","let lookahead = assignment.lookAhead","","\/\/ Use the grammar to parse a string","let input = \"x=y\"","do {","    let result = try lookahead.run(sourceName: \"lookahead\", input: input)","    print(\"Parsed successfully: \\(result)\")","} catch {","    print(\"Parsing failed with error: \\(error)\")","}",""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/lookAhead"},{"type":"text","text":" parser will check if the input matches the assignment pattern. If it does, the parser will return the matched value, but it will not consume the input. This means that after running the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/lookAhead"},{"type":"text","text":" parser, the input will remain unchanged, and the parser’s position will be at the start of the input. This is useful when you want to check for a pattern without advancing the parser’s position."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is worth mentioning that SwiftParsec provides another combinator for lookahead operations: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/attempt"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/attempt"},{"type":"text","text":" method allows us to try a parser and revert to the original state if the parser fails. This is useful when we want to try a parser that may fail, but we don’t want to consume any input if it does. In other words, attempt allows us to do speculative parsing."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that attempt and lookAhead are similar, but they have a key difference: attempt consumes the input if the parser succeeds, while lookAhead never consumes any input, whether the parser succeeds or fails."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/swiftparsec\/advanced-topics-with-swiftparsec-2"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Advanced-Topics-with-SwiftParsec-2","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"In this second part of our advanced topics guide, we will delve deeper into the capabilities of SwiftParsec. We’ll cover backtracking and lookahead, two powerful techniques that can greatly enhance the flexibility and power of your parsers."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Advanced Topics with SwiftParsec (part 2)","role":"article","modules":[{"name":"SwiftParsec"}]},"hierarchy":{"paths":[["doc:\/\/SwiftParsec\/documentation\/SwiftParsec"]]},"references":{"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/lookAhead":{"role":"symbol","title":"lookAhead","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"lookAhead"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"A combinator that parses without consuming any input."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/lookAhead","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/lookahead"},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/attempt":{"role":"symbol","title":"attempt","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"attempt"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"This combinator is used whenever arbitrary look ahead is needed. Since"},{"type":"text","text":" "},{"type":"text","text":"it pretends that it hasn’t consumed any input when "},{"type":"codeVoice","code":"self"},{"type":"text","text":" fails, the"},{"type":"text","text":" "},{"type":"text","text":"(’<|>’) combinator will try its second alternative even when the first"},{"type":"text","text":" "},{"type":"text","text":"parser failed while consuming input."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/attempt","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/attempt"},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/alternative(_:)":{"role":"symbol","title":"alternative(_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"alternative"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"This combinator implements choice. The parser "},{"type":"codeVoice","code":"p.alternative(q)"},{"type":"text","text":" first"},{"type":"text","text":" "},{"type":"text","text":"applies "},{"type":"codeVoice","code":"p"},{"type":"text","text":". If it succeeds, the value of "},{"type":"codeVoice","code":"p"},{"type":"text","text":" is returned. If "},{"type":"codeVoice","code":"p"},{"type":"text","text":" fails"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"without consuming any input"}]},{"type":"text","text":", parser "},{"type":"codeVoice","code":"q"},{"type":"text","text":" is tried. The parser is called"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"predictive"}]},{"type":"text","text":" since "},{"type":"codeVoice","code":"q"},{"type":"text","text":" is only tried when parser "},{"type":"codeVoice","code":"p"},{"type":"text","text":" didn’t consume any"},{"type":"text","text":" "},{"type":"text","text":"input (i.e.. the look ahead is 1). This non-backtracking behaviour"},{"type":"text","text":" "},{"type":"text","text":"allows for both an efficient implementation of the parser combinators"},{"type":"text","text":" "},{"type":"text","text":"and the generation of good error messages."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/alternative(_:)","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/alternative(_:)"},"doc://SwiftParsec/documentation/SwiftParsec":{"role":"collection","title":"SwiftParsec","abstract":[{"type":"text","text":"Unleash the Power of Parser Combinators in Swift!"}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec"},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/___(_:_:)-t050":{"role":"symbol","title":"<|>(_:_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"<|>"},{"kind":"text","text":" "},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Self"}],"abstract":[{"type":"text","text":"Infix operator for "},{"type":"codeVoice","code":"Parsec.alternative"},{"type":"text","text":". It has a higher precedence than"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":">>-"},{"type":"text","text":" operator."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/___(_:_:)-t050","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/___(_:_:)-t050"}}}