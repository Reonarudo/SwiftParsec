{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Absolutely, here’s how the updated section would look:"}]},{"anchor":"Monadic-Operations","level":2,"type":"heading","text":"Monadic Operations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Monadic operations, such as "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/flatMap(_:)"},{"type":"text","text":", allow you to chain parsers together in a way that the result of one parser can influence the next one. Here’s an example:"}]},{"type":"codeListing","syntax":"swift","code":["let parser = StringParser.digit.stringValue.flatMap { digit in","StringParser.character(\"a\").count(Int(digit)!).stringValue","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, we first parse a digit. We then use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/flatMap(_:)"},{"type":"text","text":" to create a new parser that matches as many ‘a’ characters as the digit we parsed. So if the input is “3aaa”, the parser will succeed, but if the input is “3aa”, it will fail because there are not enough ‘a’ characters."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftParsec also provides an alternative notation for "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/flatMap(_:)"},{"type":"text","text":" using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/__-(_:_:)"},{"type":"text","text":" operator:"}]},{"type":"codeListing","syntax":"swift","code":["let parser = StringParser.digit.stringValue >>- { digit in","StringParser.character(\"a\").count(Int(digit)!).stringValue","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This does exactly the same thing as the previous example, but some people find this notation more readable, especially when chaining multiple parsers together."}]},{"anchor":"Recursive-Parsers","level":2,"type":"heading","text":"Recursive Parsers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Recursive parsers are parsers that refer to themselves. They are useful for parsing nested or recursive structures, like parentheses or JSON."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/recursive(_:)"},{"type":"text","text":" parser that parses nested parentheses:"}]},{"type":"codeListing","syntax":"swift","code":["let parenParser: GenericParser<String, (), String> = GenericParser.recursive { parenParser in","    let openParen = StringParser.character(\"(\")","    let closeParen = StringParser.character(\")\")","    let nestedParens = openParen >>- { _ in","        parenParser >>- { inner in","            closeParen >>- { _ in","                GenericParser(result: inner)","            }","        }","    }","    return nestedParens <|> StringParser.character(\"a\").stringValue","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, "},{"type":"codeVoice","code":"parenParser"},{"type":"text","text":" is a parser that matches either a single ‘a’ character or a pair of parentheses containing another "},{"type":"codeVoice","code":"parenParser"},{"type":"text","text":". This allows it to match arbitrarily nested parentheses."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Remember, recursive parsers can be tricky to get right, and they can lead to infinite loops if not handled carefully. Make sure to have a base case that doesn’t refer to the parser itself!"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We hope this guide has given you a deeper understanding of some of the more advanced features of SwiftParsec."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/swiftparsec\/advanced-topics-in-swiftparsec"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/Advanced-Topics-in-SwiftParsec","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Welcome to the advanced topics guide for SwiftParsec! In this guide, we’ll delve deeper into some of the more complex aspects of using SwiftParsec, including monadic operations and recursive parsers."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Advanced Topics with `SwiftParsec`","role":"article","modules":[{"name":"SwiftParsec"}]},"hierarchy":{"paths":[["doc:\/\/SwiftParsec\/documentation\/SwiftParsec"]]},"references":{"doc://SwiftParsec/documentation/SwiftParsec/__-(_:_:)":{"role":"symbol","title":">>-(_:_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":">>-"},{"kind":"text","text":" "},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"StreamType"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"UserState"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"Result"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">, ("},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Infix operator for "},{"type":"codeVoice","code":"flatMap"},{"type":"text","text":" named "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bind"}]},{"type":"text","text":". It has the same precedence as the"},{"type":"text","text":" "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" coalescing operator ("},{"type":"codeVoice","code":"??"},{"type":"text","text":")."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/__-(_:_:)","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/__-(_:_:)"},"doc://SwiftParsec/documentation/SwiftParsec":{"role":"collection","title":"SwiftParsec","abstract":[{"type":"text","text":"Unleash the Power of Parser Combinators in Swift!"}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec"},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/flatMap(_:)":{"role":"symbol","title":"flatMap(_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"flatMap"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">(("},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Return a parser containing the result of mapping transform over "},{"type":"codeVoice","code":"self"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/flatMap(_:)","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/flatmap(_:)"},"doc://SwiftParsec/documentation/SwiftParsec/GenericParser/recursive(_:)":{"conformance":{"constraints":[{"type":"codeVoice","code":"StreamType"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Stream"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"recursive(_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"recursive"},{"kind":"text","text":"(("},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"GenericParser","preciseIdentifier":"s:11SwiftParsec13GenericParserC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"StreamType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"UserState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Result"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Return a recursive parser combined with itself. It can be used to parse"},{"type":"text","text":" "},{"type":"text","text":"nested expressions. As an exemple, an expression inside a pair of"},{"type":"text","text":" "},{"type":"text","text":"parentheses is itself an expression that can be nested inside another"},{"type":"text","text":" "},{"type":"text","text":"pair of parentheses."}],"identifier":"doc:\/\/SwiftParsec\/documentation\/SwiftParsec\/GenericParser\/recursive(_:)","kind":"symbol","type":"topic","url":"\/documentation\/swiftparsec\/genericparser\/recursive(_:)"}}}